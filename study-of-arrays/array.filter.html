<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>

        /* Array Filter
        O filter tem como função criar um novo array contendo apenas os elementos do array original que satisfaçam uma determinada condição.
        Ele nunca modifica o array original (mantendo a imutabilidade, um conceito que vimos com o Spread Operator).
        
        Como funciona o .filter()
        
        O Método funciona passando por cada elemento do array e executando uma função de callback (ou "função de teste") para ele. Essa função de callback deve retornar:
        
                *true: O elemento é mantido e adicionado ao novo array.
                *false: o elemento é descartado.
        
        A sintaxe fica assim:
        
                const arrayFiltrado = arrayOriginal.filter((elemento) => {
                    // Sua logica de teste aqui
                    return elemento > 10; // Exemplo de condição
                });
        
        */


        // 1. Filtragem Básica (Números)


        console.log("-- 1. Filtragem Básica (Pares) ---");

        const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        // A função de callback retorna 'true' se o número for par (resto da divisão por 2 é 0).

        const numerosPares = numeros.filter(function (numero) {
            return numero % 2 === 0;
        });

        // Usando Arrow Function (Sintaxe mais moderna e comum)

        const numerosImpares = numeros.filter(numero => numero % 2 !== 0);

        console.log("Array Original:", numeros);
        console.log("Números Pares:", numerosPares); // [2, 4, 6, 8, 10]
        console.log("Números Ímpares:", numerosImpares); // [1, 3, 5, 7, 9]

        // O array original não foi modificado:
        console.log("Array original após filtro:", numeros);



        // 2. Filtragem de Objetos

        console.log("\n --- 2. Filtragem de Objetos ---");

        const usuarios = [
            { nome: 'Ana', idade: 22, ativo: true },
            { nome: 'Pedro', idade: 16, ativo: false },
            { nome: 'Maria', idade: 35, ativo: true },
            { nome: 'João', idade: 17, ativo: true }
        ];

        // O callback verifica a propriedade 'idade' de cada objeto
        const maioresDeIdade = usuarios.filter(usuario => {
            return usuario.idade >= 18;
        })

        // Filtrar usuários ativos

        const ativos = usuarios.filter(usuario => usuario.ativo);

        console.log("Lista completa de usuários:", usuarios.length, "itens");
        console.log("Usuários Maiores de Idade:", maioresDeIdade);
        /* Saída:
        [
            {nome: 'Ana', idade: 22, ativo: true},
            {nome: 'Maria', idade: 35, ativo: true}
        ]
        */

        console.log("Usuários Ativos", ativos);

        // 3. Encadamento de métodos (Filter + map)


        console.log("\n --- 3. Encadeamento (Filter + map) ---");

        // Encadear significa chamar um método logo após o outro pois o 'filter' retorna um array, e 'map' pode ser chamado nesse array.

        const nomesDeUsuariosAtivos = usuarios

            .filter(usuario => usuario.ativo) // 1. O array resultante do filter é passado para o map
            .map(usuario => usuario.nome); // o O map pega esse novo array e extrai apenas o nome

        console.log("Usuários Ativos (Objetos);", usuarios.filter(usuarios => usuarios.ativo));
        console.log("Nomes dos Usuários Ativos (Encadeado):", nomesDeUsuariosAtivos); // ['Ana', 'Maria', 'João']







    </script>



</body>

</html>